/*
 * Copyright (C) 2024-2025 OpenAni and contributors.
 *
 * 此源代码的使用受 GNU AFFERO GENERAL PUBLIC LICENSE version 3 许可证的约束, 可以在以下链接找到该许可证.
 * Use of this source code is governed by the GNU AGPLv3 license, which can be found at the following link.
 *
 * https://github.com/open-ani/ani/blob/main/LICENSE
 */

// @formatter:off
/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package me.him188.ani.client.apis

import io.ktor.client.HttpClient
import io.ktor.client.HttpClientConfig
import io.ktor.client.engine.HttpClientEngine
import kotlinx.serialization.KSerializer
import kotlinx.serialization.Serializable
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import kotlinx.serialization.json.Json
import kotlinx.serialization.serializer
import me.him188.ani.client.infrastructure.ApiClient
import me.him188.ani.client.infrastructure.HttpResponse
import me.him188.ani.client.infrastructure.RequestConfig
import me.him188.ani.client.infrastructure.RequestMethod
import me.him188.ani.client.infrastructure.map
import me.him188.ani.client.infrastructure.wrap
import me.him188.ani.client.models.AniBangumiSyncStateEntity
import me.him188.ani.client.models.AniBatchUpdateEpisodeCollectionsRequest
import me.him188.ani.client.models.AniCollectionType
import me.him188.ani.client.models.AniEpisodeCollection
import me.him188.ani.client.models.AniPaginatedResponse
import me.him188.ani.client.models.AniRelatedCharacter
import me.him188.ani.client.models.AniRelatedPerson
import me.him188.ani.client.models.AniRelatedSubject
import me.him188.ani.client.models.AniSubjectCollection
import me.him188.ani.client.models.AniSubjectCollectionCountStats
import me.him188.ani.client.models.AniSubjectRecommendation
import me.him188.ani.client.models.AniUpdateEpisodeCollectionRequest
import me.him188.ani.client.models.AniUpdateSubjectCollectionRequest

open class SubjectsAniApi : ApiClient {

    constructor(
        baseUrl: String = ApiClient.BASE_URL,
        httpClientEngine: HttpClientEngine? = null,
        httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
        jsonSerializer: Json = ApiClient.JSON_DEFAULT
    ) : super(baseUrl = baseUrl, httpClientEngine = httpClientEngine, httpClientConfig = httpClientConfig, jsonBlock = jsonSerializer)

    constructor(
        baseUrl: String,
        httpClient: HttpClient
    ): super(baseUrl = baseUrl, httpClient = httpClient)

    /**
     * Bangumi 全量同步
     * Bangumi 全量同步
     * @return kotlin.Any
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun bangumiFullSync(): HttpResponse<kotlin.Any> {

        val localVariableAuthNames = listOf<String>("auth-jwt")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v2/subjects/bangumi/full-sync",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * 批量编辑自己的条目收藏中的剧集进度
     * 批量编辑自己的条目收藏中的剧集进度
     * @param subjectId 
     * @param aniBatchUpdateEpisodeCollectionsRequest 
     * @return kotlin.Any
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun batchUpdateEpisodeCollections(subjectId: kotlin.Long, aniBatchUpdateEpisodeCollectionsRequest: AniBatchUpdateEpisodeCollectionsRequest): HttpResponse<kotlin.Any> {

        val localVariableAuthNames = listOf<String>("auth-jwt")

        val localVariableBody = aniBatchUpdateEpisodeCollectionsRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PATCH,
            "/v2/subjects/{subjectId}/episodes/batchUpdate".replace("{" + "subjectId" + "}", "$subjectId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * 删除自己的收藏
     * 删除自己的收藏
     * @param subjectId 
     * @return kotlin.Any
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun deleteSubjectCollection(subjectId: kotlin.Long): HttpResponse<kotlin.Any> {

        val localVariableAuthNames = listOf<String>("auth-jwt")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v2/subjects/{subjectId}".replace("{" + "subjectId" + "}", "$subjectId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * 获取 Bangumi 全量同步状态
     * 获取 Bangumi 全量同步状态
     * @return AniBangumiSyncStateEntity
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getBangumiFullSyncState(): HttpResponse<AniBangumiSyncStateEntity> {

        val localVariableAuthNames = listOf<String>("auth-jwt")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v2/subjects/bangumi/full-sync/state",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * 获取单个剧集信息. 如果已登录, 还会返回 collectionType 字段
     * 获取单个剧集信息. 如果已登录, 还会返回 collectionType 字段
     * @param subjectId 
     * @param episodeId 
     * @return AniEpisodeCollection
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getEpisode(subjectId: kotlin.Long, episodeId: kotlin.Long): HttpResponse<AniEpisodeCollection> {

        val localVariableAuthNames = listOf<String>("auth-jwt")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v2/subjects/{subjectId}/episodes/{episodeId}".replace("{" + "subjectId" + "}", "$subjectId").replace("{" + "episodeId" + "}", "$episodeId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * 获取关联条目列表
     * 获取关联条目列表
     * @param subjectId 
     * @return kotlin.collections.List<AniRelatedSubject>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getRelatedSubjects(subjectId: kotlin.Long): HttpResponse<kotlin.collections.List<AniRelatedSubject>> {

        val localVariableAuthNames = listOf<String>("auth-jwt")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v2/subjects/{subjectId}/related-subjects".replace("{" + "subjectId" + "}", "$subjectId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetRelatedSubjectsResponse>().map { value }
    }

    @Serializable(GetRelatedSubjectsResponse.Companion::class)
    private class GetRelatedSubjectsResponse(val value: List<AniRelatedSubject>) {
        companion object : KSerializer<GetRelatedSubjectsResponse> {
            private val serializer: KSerializer<List<AniRelatedSubject>> = serializer<List<AniRelatedSubject>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, value: GetRelatedSubjectsResponse) = serializer.serialize(encoder, value.value)
            override fun deserialize(decoder: Decoder) = GetRelatedSubjectsResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * 获取单个条目信息. 如果已登录, 还会返回 collectionType 等字段.
     * 获取单个条目信息. 如果已登录, 还会返回 collectionType 等字段.
     * @param subjectId 
     * @return AniSubjectCollection
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getSubject(subjectId: kotlin.Long): HttpResponse<AniSubjectCollection> {

        val localVariableAuthNames = listOf<String>("auth-jwt")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v2/subjects/{subjectId}".replace("{" + "subjectId" + "}", "$subjectId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * 获取条目的角色 (characters). 默认返回配音演员.
     * 获取条目的角色 (characters). 默认返回配音演员.
     * @param subjectId 
     * @param withActors  (optional)
     * @return kotlin.collections.List<AniRelatedCharacter>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getSubjectCharacters(subjectId: kotlin.Long, withActors: kotlin.Boolean? = null): HttpResponse<kotlin.collections.List<AniRelatedCharacter>> {

        val localVariableAuthNames = listOf<String>("auth-jwt")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        withActors?.apply { localVariableQuery["withActors"] = listOf("$withActors") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v2/subjects/{subjectId}/characters".replace("{" + "subjectId" + "}", "$subjectId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetSubjectCharactersResponse>().map { value }
    }

    @Serializable(GetSubjectCharactersResponse.Companion::class)
    private class GetSubjectCharactersResponse(val value: List<AniRelatedCharacter>) {
        companion object : KSerializer<GetSubjectCharactersResponse> {
            private val serializer: KSerializer<List<AniRelatedCharacter>> = serializer<List<AniRelatedCharacter>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, value: GetSubjectCharactersResponse) = serializer.serialize(encoder, value.value)
            override fun deserialize(decoder: Decoder) = GetSubjectCharactersResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * 获取不同类型的收藏条目数量
     * 获取不同类型的收藏条目数量
     * @return AniSubjectCollectionCountStats
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getSubjectCollectionStats(): HttpResponse<AniSubjectCollectionCountStats> {

        val localVariableAuthNames = listOf<String>("auth-jwt")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v2/subjects/count",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * 获取收藏的条目列表
     * 获取收藏的条目列表
     * @param offset  (optional)
     * @param limit  (optional)
     * @param type  (optional)
     * @return AniPaginatedResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getSubjectCollections(offset: kotlin.Int? = null, limit: kotlin.Int? = null, type: AniCollectionType? = null): HttpResponse<AniPaginatedResponse> {

        val localVariableAuthNames = listOf<String>("auth-jwt")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        offset?.apply { localVariableQuery["offset"] = listOf("$offset") }
        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
        type?.apply { localVariableQuery["type"] = listOf("${ type.value }") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v2/subjects/list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * 获取番剧条目推荐列表
     * 获取番剧条目推荐列表
     * @param subjectId 
     * @param limit  (optional)
     * @return kotlin.collections.List<AniSubjectRecommendation>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getSubjectRecommendations(subjectId: kotlin.Long, limit: kotlin.Int? = null): HttpResponse<kotlin.collections.List<AniSubjectRecommendation>> {

        val localVariableAuthNames = listOf<String>("auth-jwt")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v2/subjects/{subjectId}/recommendations".replace("{" + "subjectId" + "}", "$subjectId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetSubjectRecommendationsResponse>().map { value }
    }

    @Serializable(GetSubjectRecommendationsResponse.Companion::class)
    private class GetSubjectRecommendationsResponse(val value: List<AniSubjectRecommendation>) {
        companion object : KSerializer<GetSubjectRecommendationsResponse> {
            private val serializer: KSerializer<List<AniSubjectRecommendation>> = serializer<List<AniSubjectRecommendation>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, value: GetSubjectRecommendationsResponse) = serializer.serialize(encoder, value.value)
            override fun deserialize(decoder: Decoder) = GetSubjectRecommendationsResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * 获取条目的制作人员 (staff)
     * 获取条目的制作人员 (staff)
     * @param subjectId 
     * @return kotlin.collections.List<AniRelatedPerson>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getSubjectStaff(subjectId: kotlin.Long): HttpResponse<kotlin.collections.List<AniRelatedPerson>> {

        val localVariableAuthNames = listOf<String>("auth-jwt")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v2/subjects/{subjectId}/staff".replace("{" + "subjectId" + "}", "$subjectId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetSubjectStaffResponse>().map { value }
    }

    @Serializable(GetSubjectStaffResponse.Companion::class)
    private class GetSubjectStaffResponse(val value: List<AniRelatedPerson>) {
        companion object : KSerializer<GetSubjectStaffResponse> {
            private val serializer: KSerializer<List<AniRelatedPerson>> = serializer<List<AniRelatedPerson>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, value: GetSubjectStaffResponse) = serializer.serialize(encoder, value.value)
            override fun deserialize(decoder: Decoder) = GetSubjectStaffResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * 编辑自己的条目收藏中的单个剧集进度
     * 编辑自己的条目收藏中的单个剧集进度
     * @param subjectId 
     * @param episodeId 
     * @param aniUpdateEpisodeCollectionRequest 
     * @return kotlin.Any
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun updateEpisodeCollection(subjectId: kotlin.Long, episodeId: kotlin.Long, aniUpdateEpisodeCollectionRequest: AniUpdateEpisodeCollectionRequest): HttpResponse<kotlin.Any> {

        val localVariableAuthNames = listOf<String>("auth-jwt")

        val localVariableBody = aniUpdateEpisodeCollectionRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PATCH,
            "/v2/subjects/{subjectId}/episodes/{episodeId}".replace("{" + "subjectId" + "}", "$subjectId").replace("{" + "episodeId" + "}", "$episodeId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * 编辑自己的收藏或创建一个收藏
     * 编辑自己的收藏或创建一个收藏
     * @param subjectId 
     * @param aniUpdateSubjectCollectionRequest  (optional)
     * @return kotlin.Any
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun updateSubjectCollection(subjectId: kotlin.Long, aniUpdateSubjectCollectionRequest: AniUpdateSubjectCollectionRequest? = null): HttpResponse<kotlin.Any> {

        val localVariableAuthNames = listOf<String>("auth-jwt")

        val localVariableBody = aniUpdateSubjectCollectionRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PATCH,
            "/v2/subjects/{subjectId}".replace("{" + "subjectId" + "}", "$subjectId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



}

// @formatter:on
